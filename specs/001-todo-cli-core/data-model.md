# Data Model: Todo CLI Core

**Feature**: Todo CLI Core
**Branch**: 001-todo-cli-core
**Date**: 2025-12-27
**Status**: Approved

## Overview

This document defines the data structures for the Todo CLI Core application, implementing the requirements from `spec.md` and design decisions from `research.md`. All entities use Python 3.13+ type hints and follow constitution Principle 5 (clean, beginner-friendly code with proper separation of concerns).

## Entity Definitions

### Task Entity

**Purpose**: Represents a single todo item with all associated metadata.

**Type**: Python dataclass (immutable after creation except for updates via TaskManager)

**Attributes**:

| Attribute | Type | Required | Default | Validation | Description |
|-----------|------|----------|---------|------------|-------------|
| `id` | `int` | Yes | Auto-generated | >0, unique | Sequential identifier starting from 1 |
| `title` | `str` | Yes | N/A | 1-200 chars, non-empty after strip() | Task description |
| `description` | `str \| None` | No | `None` | ≤1000 chars if provided | Optional detailed context |
| `is_complete` | `bool` | Yes | `False` | N/A | Completion status flag |
| `created_at` | `datetime` | Yes | Auto-generated | Valid datetime | Creation timestamp (local time, ISO 8601) |
| `updated_at` | `datetime` | Yes | Auto-generated | Valid datetime | Last modification timestamp (local time, ISO 8601) |

**Invariants**:
- `id` never changes after creation
- `created_at` never changes after creation
- `updated_at` changes on any modification (title, description, is_complete)
- `title` always non-empty after validation
- `description` is `None` or valid string (empty string → `None`)

**Validation Rules** (enforced by TaskManager):
1. **Title validation**:
   - Strip whitespace: `title = title.strip()`
   - Check non-empty: `if not title: raise InvalidTaskError("Title cannot be empty")`
   - Check length: `if len(title) > 200: raise InvalidTaskError("Title too long (max 200 characters)")`

2. **Description validation**:
   - Convert empty string to None: `description = description.strip() or None`
   - Check length if provided: `if description and len(description) > 1000: raise InvalidTaskError("Description too long (max 1000 characters)")`

**State Transitions**:
```
                    ┌─────────────────────────┐
                    │     Task Created        │
                    │   is_complete=False     │
                    └───────────┬─────────────┘
                                │
                                │ toggle_complete()
                                ▼
                    ┌─────────────────────────┐
                    │     Task Complete       │
                    │    is_complete=True     │
                    └───────────┬─────────────┘
                                │
                                │ toggle_complete()
                                ▼
                    ┌─────────────────────────┐
                    │    Task Incomplete      │
                    │   is_complete=False     │
                    └─────────────────────────┘

                    (Cycle repeats - idempotent toggle)
```

**Python Implementation** (from research.md decision):
```python
from dataclasses import dataclass
from datetime import datetime

@dataclass
class Task:
    """Represents a single todo item.

    Attributes:
        id: Unique sequential identifier (auto-generated by TaskManager)
        title: Task description (1-200 characters, required)
        description: Optional detailed context (max 1000 characters)
        is_complete: Completion status flag (default False)
        created_at: Creation timestamp (local time, ISO 8601)
        updated_at: Last modification timestamp (local time, ISO 8601)
    """
    id: int
    title: str
    description: str | None
    is_complete: bool
    created_at: datetime
    updated_at: datetime

    def to_display(self) -> str:
        """Format task for console display per Principle 6 specification.

        Returns:
            Formatted string: "ID: X | [X/] | Title | Created: YYYY-MM-DD HH:MM"
        """
        checkbox = "[X]" if self.is_complete else "[ ]"
        created_str = self.created_at.strftime("%Y-%m-%d %H:%M")
        result = f"ID: {self.id} | {checkbox} {self.title} | Created: {created_str}"
        if self.description:
            result += f"\n    Description: {self.description}"
        return result
```

---

### TaskManager State

**Purpose**: Manages task collection and enforces business logic.

**Type**: Python class (single instance per application session)

**Internal State**:

| Attribute | Type | Visibility | Purpose |
|-----------|------|------------|---------|
| `_tasks` | `dict[int, Task]` | Private | ID-based task storage (O(1) access) |
| `_next_id` | `int` | Private | Sequential ID counter (starts at 1) |

**Invariants**:
- `_next_id` always equals `max(task IDs) + 1` or 1 if no tasks
- `_next_id` never decrements (IDs never reused, even after deletion)
- `_tasks` keys match corresponding Task.id values
- All Task objects in `_tasks` have valid state per Task invariants

**Operations** (see contracts/cli-menu.md for detailed contracts):
1. `add_task(title: str, description: str | None) -> Task`
2. `get_all_tasks() -> list[Task]`
3. `get_task(task_id: int) -> Task | None`
4. `update_task(task_id: int, title: str | None, description: str | None) -> Task`
5. `toggle_complete(task_id: int) -> Task`
6. `delete_task(task_id: int) -> None`

**Python Implementation** (from research.md decisions):
```python
class InvalidTaskError(Exception):
    """Raised when task validation fails."""
    pass

class TaskNotFoundError(Exception):
    """Raised when task ID does not exist."""
    pass

class TaskManager:
    """Manages todo tasks with CRUD operations and validation.

    This class enforces all business rules from spec.md Principle 4:
    - Title validation (1-200 chars, non-empty)
    - Description validation (max 1000 chars)
    - Sequential ID generation
    - Timestamp management (created_at, updated_at)
    - Error handling for invalid operations
    """

    def __init__(self):
        """Initialize empty task manager."""
        self._tasks: dict[int, Task] = {}
        self._next_id: int = 1

    def add_task(self, title: str, description: str | None = None) -> Task:
        """Add a new task with validation.

        Args:
            title: Task description (will be stripped and validated)
            description: Optional context (will be stripped, empty → None)

        Returns:
            Newly created Task with auto-generated ID and timestamps

        Raises:
            InvalidTaskError: If title is empty or exceeds limits
        """
        # Validation (from research.md decision #3)
        title = title.strip()
        if not title:
            raise InvalidTaskError("Title cannot be empty")
        if len(title) > 200:
            raise InvalidTaskError("Title too long (max 200 characters)")

        description = description.strip() if description else None
        if description == "":
            description = None
        if description and len(description) > 1000:
            raise InvalidTaskError("Description too long (max 1000 characters)")

        # Create task (from research.md decision #1: local time)
        now = datetime.now()
        task = Task(
            id=self._next_id,
            title=title,
            description=description,
            is_complete=False,
            created_at=now,
            updated_at=now
        )

        self._tasks[self._next_id] = task
        self._next_id += 1
        return task

    def get_all_tasks(self) -> list[Task]:
        """Get all tasks in insertion order.

        Returns:
            List of tasks (empty list if no tasks)
        """
        # Python 3.13+ dicts maintain insertion order (research.md decision #2)
        return list(self._tasks.values())

    def get_task(self, task_id: int) -> Task | None:
        """Get task by ID.

        Args:
            task_id: Task identifier

        Returns:
            Task if found, None otherwise
        """
        return self._tasks.get(task_id)

    def update_task(
        self,
        task_id: int,
        title: str | None = None,
        description: str | None = None
    ) -> Task:
        """Update task title and/or description.

        Args:
            task_id: Task identifier
            title: New title (None = no change)
            description: New description (None = no change, "" = clear description)

        Returns:
            Updated task with new updated_at timestamp

        Raises:
            TaskNotFoundError: If task_id doesn't exist
            InvalidTaskError: If validation fails
        """
        task = self._tasks.get(task_id)
        if not task:
            raise TaskNotFoundError(f"Task ID {task_id} does not exist")

        # Validate title if provided
        if title is not None:
            title = title.strip()
            if not title:
                raise InvalidTaskError("Title cannot be empty")
            if len(title) > 200:
                raise InvalidTaskError("Title too long (max 200 characters)")

        # Validate description if provided
        if description is not None:
            description = description.strip() or None
            if description and len(description) > 1000:
                raise InvalidTaskError("Description too long (max 1000 characters)")

        # Create updated task (immutable dataclass pattern)
        updated_task = Task(
            id=task.id,
            title=title if title is not None else task.title,
            description=description if description is not None else task.description,
            is_complete=task.is_complete,
            created_at=task.created_at,
            updated_at=datetime.now()
        )

        self._tasks[task_id] = updated_task
        return updated_task

    def toggle_complete(self, task_id: int) -> Task:
        """Toggle task completion status.

        Args:
            task_id: Task identifier

        Returns:
            Updated task with toggled is_complete and new updated_at

        Raises:
            TaskNotFoundError: If task_id doesn't exist
        """
        task = self._tasks.get(task_id)
        if not task:
            raise TaskNotFoundError(f"Task ID {task_id} does not exist")

        updated_task = Task(
            id=task.id,
            title=task.title,
            description=task.description,
            is_complete=not task.is_complete,  # Toggle
            created_at=task.created_at,
            updated_at=datetime.now()
        )

        self._tasks[task_id] = updated_task
        return updated_task

    def delete_task(self, task_id: int) -> None:
        """Permanently delete task.

        Args:
            task_id: Task identifier

        Raises:
            TaskNotFoundError: If task_id doesn't exist
        """
        if task_id not in self._tasks:
            raise TaskNotFoundError(f"Task ID {task_id} does not exist")

        del self._tasks[task_id]
```

---

## Relationships

```
┌─────────────────────────────────────┐
│         TaskManager                 │
│  ┌──────────────────────────────┐   │
│  │ _tasks: dict[int, Task]      │   │
│  │ _next_id: int                │   │
│  └──────────────────────────────┘   │
│                                     │
│  Operations:                        │
│  - add_task()                       │
│  - get_all_tasks()                  │
│  - get_task()                       │
│  - update_task()                    │
│  - toggle_complete()                │
│  - delete_task()                    │
└─────────┬───────────────────────────┘
          │
          │ manages 0..*
          │
          ▼
┌─────────────────────────────────────┐
│            Task                     │
│  ┌──────────────────────────────┐   │
│  │ id: int                      │   │
│  │ title: str                   │   │
│  │ description: str | None      │   │
│  │ is_complete: bool            │   │
│  │ created_at: datetime         │   │
│  │ updated_at: datetime         │   │
│  └──────────────────────────────┘   │
│                                     │
│  Methods:                           │
│  - to_display() -> str              │
└─────────────────────────────────────┘
```

**Cardinality**: One TaskManager manages zero or more Tasks (0..*)

**Ownership**: TaskManager owns all Tasks (tasks don't exist independently)

**Lifecycle**: Tasks created by TaskManager, modified only through TaskManager methods

---

## Data Flow

**Add Task Flow**:
```
User Input → CLI.add_task_flow()
           → TaskManager.add_task(title, desc)
           → Validate title/description
           → Create Task with ID, timestamps
           → Store in _tasks dict
           → Return Task
           → CLI displays confirmation
```

**Update Task Flow**:
```
User Input (ID, new title/desc) → CLI.update_task_flow()
                                → TaskManager.update_task(id, title, desc)
                                → Validate ID exists
                                → Validate new title/description
                                → Create updated Task (immutable pattern)
                                → Replace in _tasks dict
                                → Return updated Task
                                → CLI displays confirmation
```

**View Tasks Flow**:
```
User Input → CLI.view_tasks_flow()
           → TaskManager.get_all_tasks()
           → Return list[Task] (insertion order)
           → CLI calls task.to_display() for each
           → Display formatted output
           (or "No tasks found" if empty)
```

---

## Memory Considerations

**Task Size Estimate**:
- `id`: 28 bytes (Python int)
- `title`: 50-250 bytes (average 100 bytes)
- `description`: 0-1050 bytes (average 200 bytes if provided)
- `is_complete`: 28 bytes (Python bool)
- `created_at`, `updated_at`: 48 bytes each (Python datetime)
- **Total per Task**: ~300-400 bytes average

**Capacity Estimate**:
- 1000 tasks ≈ 300-400 KB
- 10,000 tasks ≈ 3-4 MB
- Python dict overhead: ~2x multiplier = 6-8 MB for 10,000 tasks

**Conclusion**: In-memory storage is feasible for Phase I scope (100-1000 tasks typical, per spec Assumption 6)

---

## Compliance Matrix

| Requirement | Entity/Method | Validation |
|-------------|---------------|------------|
| FR-001 (add task, title 1-200, desc ≤1000) | TaskManager.add_task() | ✅ Title/description validation |
| FR-002 (sequential IDs from 1) | TaskManager._next_id | ✅ Increments from 1, never reused |
| FR-003 (creation timestamp ISO 8601) | Task.created_at | ✅ datetime.now().isoformat() |
| FR-004 (updated timestamp ISO 8601) | Task.updated_at | ✅ Set on create, updated on modify |
| FR-005 (display ID, status, title, timestamp, desc) | Task.to_display() | ✅ Matches Principle 6 format |
| FR-006 ("No tasks found" when empty) | TaskManager.get_all_tasks() | ✅ Returns empty list, CLI handles |
| FR-007 (toggle complete by ID) | TaskManager.toggle_complete() | ✅ Idempotent toggle |
| FR-008 (update title/description by ID) | TaskManager.update_task() | ✅ Validates updates |
| FR-009 (delete by ID) | TaskManager.delete_task() | ✅ Permanent removal |
| FR-010 (reject empty title) | TaskManager.add_task(), update_task() | ✅ Raises InvalidTaskError |
| FR-011 (reject title >200) | TaskManager.add_task(), update_task() | ✅ Raises InvalidTaskError |
| FR-012 (reject desc >1000) | TaskManager.add_task(), update_task() | ✅ Raises InvalidTaskError |
| FR-013 (error for invalid ID) | All TaskManager ID operations | ✅ Raises TaskNotFoundError |
| FR-014 (allow duplicate titles) | TaskManager (no uniqueness check) | ✅ No title validation against existing |
| FR-017 (in-memory only) | TaskManager._tasks (dict, no persistence) | ✅ No file/DB operations |

---

## Next Steps

- ✅ Data model complete and approved
- ⏩ Create contracts/cli-menu.md (CLI interface specifications)
- ⏩ Create quickstart.md (setup and demo workflow)
- ⏩ Generate tasks.md via `/sp.tasks` (implementation tasks)
